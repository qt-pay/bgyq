# 乐观锁和悲观锁

## 乐观锁：主流

乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案一般来说有两种：`版本号机制` 和 `CAS实现` 。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。

乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。

乐观锁的适用场景有很多，典型的比如说成本系统，柜员要对一笔金额做修改，为了保证数据的准确性和实效性，使用悲观锁锁住某个数据后，再遇到其他需要修改数据的操作，那么此操作就无法完成金额的修改，对产品来说是灾难性的一刻，使用乐观锁的版本号机制能够解决这个问题

> etcd不就是基于版本号机制的乐观锁？？？

### 版本号机制

版本号机制是在数据表中加上一个 `version` 字段来实现的，表示数据被修改的次数，当执行写操作并且写入成功后，version = version + 1，当线程A要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -> 重试机制，这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取不到锁的情况，另外，自旋循环对于性能开销比较大。

### CAS

CAS的一般操作

```
bool compare_and_swap (int *oldval, int *dest, int newval) {
  if (*oldval == *dest) {
      *dest = newval;
      return true;
  }
  return false;
}
```

CAS 即 `compare and swap（比较与交换）`，是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization)

CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。 CAS执行结果要么成功要么失败，对于失败的情形下一班采用不断重试。或者放弃。

ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。

关于ABA问题我想了一个例子：在你非常渴的情况下你发现一个盛满水的杯子，你一饮而尽。之后再给杯子里重新倒满水。然后你离开，当杯子的真正主人回来时看到杯子还是盛满水，他当然不知道是否被人喝完重新倒满。解决这个问题的方案的一个策略是每一次倒水假设有一个自动记录仪记录下，这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。这也是解决ABA问题目前采用的策略。

> 我的理解是ABA本质是可循环利用的指针导致数据错乱和内存回收无关,是因为数据错乱了而立马主动回收pop后的A导致有可能多线程竞争的其他pop会出现非法访问已经释放的A指针

作者：寻寒

CAS 中涉及三个要素：

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

CAS有三个操作参数：内存地址，期望值，要修改的新值，当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，只有相等时，才会将内存中的值改为新的值，并返回成功。

### ABA 问题

通俗来讲就是你大爷还是你大爷，你大妈已经不是你大妈了^_^

举个例子

A --> B --> C

假设你有个用单链表实现的栈，如上面所示，有个head指针指向栈顶的A 用CAS原子操作，你可能会这样实现push和pop

```
push(node):
    curr := head
    old := curr
    node->next = curr
    // CAS返回旧值，old是期待的值，应该要用!=来比较
    while (old != (curr = CAS(&head, curr, node))) {
        old = curr
        node->next = curr
    }

pop(node):
    curr := head
    old := curr
    node->next = curr
    while (old != (curr = CAS(&head, curr, node))) {
        old = curr
        node = curr->next
    }
```

ABA的问题在于，pop函数中，next = curr->next 和 while之间，线程被切换走，然后其他线程先把A弹出，又把B弹出，然后又把A压入，**栈变成 了A --> C**，此时head还是指向A，等pop被切换回来继续执行，就把head指向B了。

> "pop函数中，next = curr->next 和 while之间，线程被切换走，然后其他线程先把A弹出" head在跑第一次while的时候已经指向了B，其他程序再pop的时候就没有“先弹出A”的情况了 ????
>
> ???

因此ABA问题的本质是内存回收的问题，对于上面的例子，就是A被弹出后，需要保证它的内存不能立即释放（因为还有线程引用它），也就不能立即被重用。这是新手使用CAS最常见的坑，实际项目中，通常配合128位CAS、引用计数、序列号或者HazardPointer等技术来避免ABA问题。

ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。

### ABA的危害

下面是一段伪代码，将就着看一下。场景是用链表来实现一个栈，初始化向栈中压入B、A两个元素，栈顶head指向A元素。

在某个时刻，线程1试图将栈顶换成B，但它获取栈顶的oldValue（为A）后，被线程2中断了。线程2依次将A、B弹出，然后压入C、D、A。然后换线程1继续运行，线程1执行compareAndSet发现head指向的元素确实与oldValue一致，都是A，所以就将head指向B了。但是，注意我标黄的那行代码，线程2在弹出B的时候，将B的next置为null了，因此在线程1将head指向B后，栈中只剩了一个孤零零的元素B。但按预期来说，栈中应该放的是B → A → D → C。

```
Node head;
head = B;
A.next = head;
head = A;


Thread thread1 = new Thread(
    ->{
          oldValue = head;
          sleep(3秒);
          compareAndSet(oldValue, B);

    }
);

Thread thread2 = new Thread(
    ->{
        // 弹出A
          newHead = head.next;
          head.next = null; //即A.next = null;
          head = newHead;
         // 弹出B
          newHead = head.next;
          head.next = null; // 即B.next = null;
          head = newHead; // 此时head为null
          
          // 压入C
          head = C;
          // 压入D
          D.next = head;
          head = D;
          // 压入A
          A.next = D;
          head = A;
          

    }
);

thread1.start();
thread2.start();
```



end

## 悲观锁

