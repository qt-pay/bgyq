## Golang dlv

### Delve

Delve is a source level debugger for Go programs.

>  dlv 元音全去掉了

Delve 是使用 Go 编写的 Go 程序的调试器。 它可以通过在用户代码以及运行时中的任意位置添加断点来逐步调试，甚至可以使用以二进制文件和 core dump 为参数的命令 `dlv core` 调试 core dump。

在Linux服务器上没有JetBrains tool，所以需要一个命令行调试工具

#### install

```bash
$ go get -u github.com/go-delve/delve/cmd/dlv
$ go install  github.com/go-delve/delve/cmd/dlv@latest

## 报错了？
$ go install  github.com/go-delve/delve/cmd/dlv@latest
can't load package: package github.com/go-delve/delve/cmd/dlv@latest: can only use path@version syntax with 'go get'

## 这样执行ok
$ go install  github.com/go-delve/delve/cmd/dlv
```





```bash
Examine a core dump (only supports linux and windows core dumps).

The core command will open the specified core file and the associated
executable and let you examine the state of the process when the
core dump was taken.

Currently supports linux/amd64 and linux/arm64 core files, windows/amd64 minidumps and core files generated by Delve's 'dump' command.

```



### GOTRACEBACK

`GOTRACEBACK` 控制程序崩溃时输出的详细程度。 它可以采用不同的值：

- `none` 不显示任何 goroutine 栈 trace。
- `single`, 默认选项，显示当前 goroutine 栈 trace。
- `all` 显示所有用户创建的 goroutine 栈 trace。
- `system` 显示所有 goroutine 栈 trace,甚至运行时的 trace。
- `crash` 类似 `system`, 而且还会生成 core dump。

#### core dump

core dump 文件是操作系统提供给我们的一把利器，它是程序意外终止时产生的内存快照。利用 core dump，我们可以在程序崩溃后更好地恢复事故现场，为故障排查保驾护航。

```go
// 由于 mac 系统下的 Go 限制了生成 core dump 文件，这个在 Go 源码 src/runtime/signal_unix.go 中有相关说明
//go:nosplit
func crash() {
 // OS X core dumps are linear dumps of the mapped memory,
 // from the first virtual byte to the last, with zeros in the gaps.
 // Because of the way we arrange the address space on 64-bit systems,
 // this means the OS X core file will be >128 GB and even on a zippy
 // workstation can take OS X well over an hour to write (uninterruptible).
 // Save users from making that mistake.
 if GOOS == "darwin" && GOARCH == "amd64" {
  return
 }
 
 dieFromSignal(_SIGABRT)
}
```



### dlv调试

#### overview

```bash
$ tree /data/golang_code/debug/
/data/golang_code/debug/
├── core
├── go.mod
├── t2.go
└── test // go build t2.go 生成的二进制文件

0 directories, 4 files

# dlv core file_name core_name
# 文件名错误会提示下面错误
$ dlv  core t2 core
open t2: no such file or directory

## 非交互式
$ dlv  core t2.go core
bad magic number '[112 97 99 107]' in record at byte 0x0

# dlv + elf 会进入交互式调试页面
$ dlv  core test core
Type 'help' for list of commands.
(dlv) quit

```



#### help

查看dlv是使用手册

```bash
$ dlv core test core
Type 'help' for list of commands.
(dlv) help
The following commands are available:

Running the program:
    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)
    # c, continue
    continue (alias: c) --------- Run until breakpoint or program termination.
    next (alias: n) ------------- Step over to next source line.
    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.
    restart (alias: r) ---------- Restart process.
    rev ------------------------- Reverses the execution of the target program for the command specified.
    rewind (alias: rw) ---------- Run backwards until breakpoint or start of recorded history.
    step (alias: s) ------------- Single step through program.
    step-instruction (alias: si)  Single step a single cpu instruction.
    stepout (alias: so) --------- Step out of the current function.

Manipulating breakpoints:
    break (alias: b) ------- Sets a breakpoint.
    breakpoints (alias: bp)  Print out info for active breakpoints.
    clear ------------------ Deletes breakpoint.
    clearall --------------- Deletes multiple breakpoints.
    condition (alias: cond)  Set breakpoint condition.
    on --------------------- Executes a command when a breakpoint is hit.
    toggle ----------------- Toggles on or off a breakpoint.
    trace (alias: t) ------- Set tracepoint.
    watch ------------------ Set watchpoint.

Viewing program variables and memory:
    args ----------------- Print function arguments.
    display -------------- Print value of an expression every time the program stops.
    examinemem (alias: x)  Examine raw memory at the given address.
    locals --------------- Print local variables.
    print (alias: p) ----- Evaluate an expression.
    regs ----------------- Print contents of CPU registers.
    set ------------------ Changes the value of a variable.
    vars ----------------- Print package variables.
    whatis --------------- Prints type of an expression.

Listing and switching between threads and goroutines:
    goroutine (alias: gr) -- Shows or changes current goroutine
    goroutines (alias: grs)  List program goroutines.
    thread (alias: tr) ----- Switch to the specified thread.
    threads ---------------- Print out info for every traced thread.

Viewing the call stack and selecting frames:
    deferred --------- Executes command in the context of a deferred call.
    down ------------- Move the current frame down.
    frame ------------ Set the current frame, or execute command on a different frame.
    stack (alias: bt)  Print stack trace.
    up --------------- Move the current frame up.

Other commands:
    check (alias: checkpoint) ----------- Creates a checkpoint at the current position.
    checkpoints ------------------------- Print out info for existing checkpoints.
    clear-checkpoint (alias: clearcheck)  Deletes checkpoint.
    config ------------------------------ Changes configuration parameters.
    disassemble (alias: disass) --------- Disassembler.
    dump -------------------------------- Creates a core dump from the current process state
    edit (alias: ed) -------------------- Open where you are in $DELVE_EDITOR or $EDITOR
    exit (alias: quit | q) -------------- Exit the debugger.
    funcs ------------------------------- Print list of functions.
    help (alias: h) --------------------- Prints the help message.
    libraries --------------------------- List loaded dynamic libraries
    list (alias: ls | l) ---------------- Show source code.
    source ------------------------------ Executes a file containing a list of delve commands
    sources ----------------------------- Print list of source files.
    transcript -------------------------- Appends command output to a file.
    types ------------------------------- Print list of types

Type help followed by a command for full documentation.
(dlv)

```



#### goroutine+bt+frame

生成core文件和查看是哪个goroutine抛出的异常

```bash
## code
$ cat t2.go
...
func main()  {
        go func(){
           time.Sleep(1200 * time.Second)
        }()
        s := "test"
        b := String2Bytes(s)
        fmt.Println(b)
        //b = append(b, 11)
        b[1] = 65
        s = Bytes2String(b)
        fmt.Println(s)
}


$ GOTRACEBACK=crash ./test
[116 101 115 116]
unexpected fault address 0x494801
fatal error: fault
[signal SIGSEGV: segmentation violation code=0x2 addr=0x494801 pc=0x47e5c0]

goroutine 1 [running]:
....

goroutine 2 [force gc (idle)]:
...

goroutine 3 [GC sweep wait]:
...

goroutine 4 [GC scavenge wait]:
...

goroutine 17 [finalizer wait]:
...

goroutine 18 [sleep]:
runtime.gopark(0x45a7949b2cb5f0, 0x0, 0x0, 0x0, 0x0)
        /usr/local/go/src/runtime/proc.go:366 +0xd6 fp=0xc000026788 sp=0xc000026768 pc=0x432436
time.Sleep(0x1176592e000)
        /usr/local/go/src/runtime/time.go:193 +0x12e fp=0xc0000267c8 sp=0xc000026788 pc=0x457e8e
## 可以看出是main.main goroutinue出现异常
main.main.func1()
        /data/golang_code/debug/t2.go:32 +0x25 fp=0xc0000267e0 sp=0xc0000267c8 pc=0x47e665
runtime.goexit()
        /usr/local/go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc0000267e8 sp=0xc0000267e0 pc=0x45ade1
created by main.main
        /data/golang_code/debug/t2.go:31 +0x34
Aborted (core dumped)

```

使用dlv进入调试模式



```bash
##  goroutines (alias: grs)  List program goroutines.
##  goroutine (alias: gr) -- Shows or changes current goroutine
##  bt: Print stack trace.
##  frame: Set the current frame, or execute command on a different frame.
##  带星号的表示为当前goroutine
$ dlv core test core
(dlv) goroutines
* Goroutine 1 - User: ./t2.go:40 main.main (0x47e5c0) (thread 3444)
  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [force gc (idle)]
  Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC sweep wait]
  Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC scavenge wait]
  Goroutine 17 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [finalizer wait]
  Goroutine 18 - User: /usr/local/go/src/runtime/time.go:193 time.Sleep (0x457e8e) [sleep]
[6 goroutines]
## goroutine 
(dlv) goroutine 18
Switched from 1 to 18 (thread 3444)
(dlv) goroutines
  Goroutine 1 - User: ./t2.go:40 main.main (0x47e5c0) (thread 3444)
  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [force gc (idle)]
  Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC sweep wait]
  Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC scavenge wait]
  Goroutine 17 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [finalizer wait]
* Goroutine 18 - User: /usr/local/go/src/runtime/time.go:193 time.Sleep (0x457e8e) [sleep]
[6 goroutines]
(dlv) goroutine 1
Switched from 18 to 1 (thread 3444)
(dlv) goroutines
* Goroutine 1 - User: ./t2.go:40 main.main (0x47e5c0) (thread 3444)
  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [force gc (idle)]
  Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC sweep wait]
  Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [GC scavenge wait]
  Goroutine 17 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x432436) [finalizer wait]
  Goroutine 18 - User: /usr/local/go/src/runtime/time.go:193 time.Sleep (0x457e8e) [sleep]
[6 goroutines]
## 查看stack
(dlv) bt
0  0x000000000045c661 in runtime.raise
   at /usr/local/go/src/runtime/sys_linux_amd64.s:165
1  0x0000000000458d00 in runtime.systemstack_switch
   at /usr/local/go/src/runtime/asm_amd64.s:350
2  0x000000000042fbd0 in runtime.fatalthrow
   at /usr/local/go/src/runtime/panic.go:1250
3  0x000000000042f991 in runtime.throw
   at /usr/local/go/src/runtime/panic.go:1198
4  0x0000000000443496 in runtime.sigpanic
   at /usr/local/go/src/runtime/signal_unix.go:742
   ## 可以看到从frame 5 开始后面的都是goexit了
5  0x000000000047e5c0 in main.main
   at ./t2.go:40
6  0x0000000000432067 in runtime.main
   at /usr/local/go/src/runtime/proc.go:255
7  0x000000000045ade1 in runtime.goexit
   at /usr/local/go/src/runtime/asm_amd64.s:1581

## 切换到第五帧，即跳转到b[1]=65
(dlv) frame 5
> runtime.raise() /usr/local/go/src/runtime/sys_linux_amd64.s:165 (PC: 0x45c661)
Warning: debugging optimized function
Frame 5: ./t2.go:40 (PC: 47e5c0)
    35:         b := String2Bytes(s)
    36:         runtime.KeepAlive(b)
    37:         runtime.KeepAlive(s)
    38:         fmt.Println(b)
    39:         //b = append(b, 11)
=>  40:         b[1] = 65
    41:         s = Bytes2String(b)
    42:         fmt.Println(s)
    43: }
 ## down: Move the current frame down.
(dlv) down执行下一个frame，然后就报错了...
> runtime.raise() /usr/local/go/src/runtime/sys_linux_amd64.s:165 (PC: 0x45c661)
Warning: debugging optimized function
Frame 4: /usr/local/go/src/runtime/signal_unix.go:742 (PC: 443496)
   737:                 // Support runtime/debug.SetPanicOnFault.
   738:                 if g.paniconfault {
   739:                         panicmemAddr(g.sigcode1)
   740:                 }
   741:                 print("unexpected fault address ", hex(g.sigcode1), "\n")
=> 742:                 throw("fault")
   743:         case _SIGFPE:
   744:                 switch g.sigcode0 {
   745:                 case _FPE_INTDIV:
   746:                         panicdivide()
   747:                 case _FPE_INTOVF:
(dlv)

```

end

### dlv demo：要求golang 1.13

```bash
$ cat -n /tmp/test.go
     1  package main
     2  import "fmt"
     3
     4  func main(){
     5    go func(n int){
     6      for{
     7        n++
     8        fmt.Println(n)
     9      }
    10    }(9)
    11    for{}
    12  }

$ go build test.go
$  ls
test  test.go
$ ./test
9
...

482299
482300
<hang>

# 
$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 14:56 pts/0    00:00:00 bash
root         461       1 95 15:00 pts/0    00:00:45 ./test
root         466       0  0 15:00 pts/1    00:00:00 bash
root         472     466  0 15:01 pts/1    00:00:00 ps -ef
# dlv attch test pid
$ dlv attach 461
Type 'help' for list of commands.
## 可以缩写为grs
(dlv) goroutines
## test.go line 11 是main{}中的for{}
* Goroutine 1 - User: /tmp/test.go:11 main.main (0x48cf9e) (thread 461)
  Goroutine 2 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [force gc (idle)]
  Goroutine 3 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [GC sweep wait]
  Goroutine 4 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [GC scavenge wait]
  Goroutine 5 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [GC worker (idle)]
  Goroutine 6 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [GC worker (idle)]
  Goroutine 17 - User: /usr/local./src/runtime/proc.go:305 runtime.gopark (0x42b4e0) [finalizer wait]
## test.go line 8 是main{}中的fmt.Println()
  Goroutine 18 - User: /tmp/test.go:8 main.main.func1 (0x48cfe7) (thread 465)
[8 goroutines]

[8 goroutines]
## 切换到 goroutine 18，查看
(dlv) gr 18
Switched from 1 to 18 (thread 465)
## 查看goroutine stack
(dlv) bt
0  0x0000000000455553 in runtime.futex
   at /usr/local./src/runtime/sys_linux_amd64.s:536
1  0x0000000000451700 in runtime.systemstack_switch
   at /usr/local./src/runtime/asm_amd64.s:330
2  0x0000000000417457 in runtime.gcStart
##  实际阻塞发送在这里
   at /usr/local./src/runtime/mgc.go:1287
3  0x000000000040b026 in runtime.mallocgc
   at /usr/local./src/runtime/malloc.go:1115
4  0x0000000000408f8b in runtime.convT64
   at /usr/local./src/runtime/iface.go:352
5  0x000000000048cfe7 in main.main.func1
   at /tmp/test.go:8
## 栈底为什么是 goexit
6  0x0000000000453651 in runtime.goexit
   at /usr/local./src/runtime/asm_amd64.s:1357
(dlv)


## 查看阻塞源代码
$ cat -n /usr/local/go/src/runtime/mgc.go|grep 1287
  1287          systemstack(stopTheWorldWithSema)
```

#### stopTheWorld导致hang

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/golang-gc-stw.jpg)

GC STW的作用是抢占正在运行goroutine，将P标志为`_Pgcstop`，使其不在运行新的goroutine.

`P` 代表 Logical Processor，是类似于 CPU 核心的概念

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/go-1.13-stw-1.jpg)

golang 1.13 依赖栈增长实现检测即如果当前goroutine没有新的函数调用，就可以运行它一直执行...

所以就导致了，上面例子中代码hang

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/go-1.12-stw-2.jpg)

#### 疑惑？

为什么要触发GC呢？

### 引用

1. https://xie.infoq.cn/article/470960b2a41d7b33ff9fe0d6e