## Golang 浮点数

计算机是二进制的世界。

### 位置，进制，符号

0.1 是什么意思？是1*10^-1，向右数数的结果。小数点是为了区分个位的位置在哪里。

一个数要用“数位表示法”表示出来，必然需要能够化为`x*10^k`的形式，而并不是任意数都能够做到。从数位法小数的定义看可以得知，一个数要能够被表示出来，需要能除尽10，才有若干个`x*10^k `的数位组合表示它，否则就是无数个符号才能表示。如1/3这个数除以10等于`1/3*1/10 = 0.0333333…`循环小数。

究竟哪些数可以用十进制表示哪些不可以？如分母是10的因子和**因子的合数**，如1，2，5，10，20，50等（**整数分母为1，而任意大于1的数的因子都有1和自身，因此整数可以用任意数制精确表示**）。

> **合数**（也称为**合成数**）是除了1和其本身外具有其他正因数的正整数。例如，整数14是一个合数，因为它可以被分解成`2*7`。而整数2无法再找到本身和1以外的正因数，因此不是合数。

回答题目，为什么0.1无法被二进制小数表示，0.1即1/10这个数要转换成二进制即`x*2^k`的组合数。

那么2进制能够表示哪些十进制小数，5/10，因为能约成1/2，分母是2的因子。

总结一点，就是位置表示法有其自身的缺陷，并不能在有限的数位，表示众多有理数，这个时候，需要借助分数来帮忙，来避免位置表示法以固定数作分母这个缺点。

如果需要一个可以避免循环小数的数制，不妨试用210进制，因为因子比较多:`2*3*5*7 =210`.



### 1/2

1/2=0.5 这事十进制的计算结果，二进制下计算结果为1/2=0.1



### 0.1

0.1在二进制中是`(1/2)^(-1)`

计算原理

考虑一个十进制小数0.123，我们可以用“乘10取整”法得到它的每一位小数：第一位小数是`0.123*10=1.23`，取整数1；第二位小数：0.23*10=2.3，取整数2……

上面的方法供你直观理解，下面我从数学的角度分析其中的原理。

现在有一个十进制小数为0.625，要把它转换为二进制小数，我们需要找到它的每一位。记这个二进制小数点后第1位是a1，第二位是a2，……，那么这个小数的值就是`a1*(1/2)^(-1)+a2*(1/2)^(-2)+a3*(1/2)^(-3)+…`。现在我们的目标是根据0.625找到对应的a1,a2,a3,…使得`0.625=a1*(1/2)^(-1)+a2*(1/2)^(-2)+a3*(1/2)^(-3)+…`

在等式两边同时乘以2，得到`1.25=a1*(1/2)^(0)+a2*(1/2)^(-1)+a3*(1/2)^(-2)+…`

我们发现，左边的整数部分1对应右边的a1，也就是二进制小数的第一位，于是a1=1，对于剩下的部分：

`0.25=a2*(1/2)^(-1)+a3*(1/2)^(-2)+…`

我们再次乘以2，得到`0.5=a2*(1/2)^(0)+a3*(1/2)^(-1)+… `于是a2=0

再乘以2，得到`1=a3*(1/2)^(0)+…`， 于是a3=1，到这里，所有的数都消耗完了，我们找到了0.625对应的二进制小数：0.101


0.1(十进制) = 0.0001100110011001(二进制)
十进制数0.1转二进制计算过程：

```bash
0.1*2＝0.2……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。
0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。
0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。
0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。
0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。
0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。
0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。
0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。
0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。
0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。
0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。
0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。
...
...
```

所以，得到的整数依次是：“0”，“0”，“0”，“1”，“1”，“0”，“0”，“1”，“1”，“0”，“0”，“1”……。
由此，大家肯定能看出来，整数部分出现了无限循环。
十进制小数转换成二进制数和十进制整数转换成二进制数不同。十进制整数转换成二进制数需要将得到的余数倒序排列，而十进制小数转换成二进制数只需要将得到的整数按照正常的顺序排列就行了。最后将十进制原数0.1中的整数部分“0”补充到按正常顺序排列的得到的“整数”前面，即：
十进制数0.1对应的二进制数是
0.000110011001...
整数的转换是精确的，小数的转换可能出现无穷不循环小数或无限循环小数的情况。此时需要进行舍入处理以截断，所以小数的转换可能略有偏差。





### 计算机为什么不能精确

**因为实数不可数，以及可计算数是否相等不可判定**

常见的计算机内的数值表达方式实际上有很多种，如整数、定点数、浮点数大部分人都很熟悉，但实际上不仅仅有二进制，还有十进制数，比如Python的decimal库，可以试试看：

```python
>>> from decimal import Decimal
>>> 1.2 - 1.0
0.19999999999999996
>>> Decimal('1.2') - Decimal('1.0')
Decimal('0.2')
```

许多可以轻松地用十进制表示的数字不能用二进制浮点表示。例如，在输入以下语句后:

```python
>>> x = 1.2
```

为 `x` 存储的值是与十进制的值 `1.2` (非常接近) 的近似值，但不完全等于它。 在典型的机器上，实际存储的值是：

```python
1.0011001100110011001100110011001100110011001100110011 (binary)
```

它对应于十进制数值:

```python
1.1999999999999999555910790149937383830547332763671875 (decimal)
```

典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。



本质上是因为计算机不能精确计算无限的数。

但是这种无限，其实有多个层面。

第0层：十进制是个[有限小数](https://www.zhihu.com/search?q=有限小数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})，二进制也是个有限小数，比如 0.5, 0.25, 0.125, 0.375 等等小数。

第一层：十进制是一个有限小数，二进制是个[无限小数](https://www.zhihu.com/search?q=无限小数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})。比如 0.2 这样的数。

第二层，十进制二进制都是无限小数，但可以表达为分数，并且分子分母都是有限的二进制数。

第三层，十进制二进制都是无限小数，不可以表达为分数，但可以通过特定的数学符号运算稳定获得。

第四层，无论在何种形态都是无限小数，无法表达为有限分数，也无法用有限的数学符号运算获得。

------

第四层的小数是几乎所有计算机程序都无法精确计算的。

第三层的小数，在一部分支持符号计算的数学工具内可以进行精确计算（直接以符号形态进行多项式计算）。在大部分普通应用中无法精确计算。

第二层的小数，在支持分数运算的数学工具内可以精确计算，在大部分普通应用内无法精确计算。

第一层的小数，使用一部分基于十进制运算的库可以精确计算，在大部分二进制计算的应用内无法精确计算。——原因也很明确，计算机无法精确计算无限，而这些数在二进制下是无限小数。

至于第〇层的小数，其实所有应用程序都能够精确计算，精确储存。——所有的整数其实都满足第零层规律，因此这些整数是能够精确的保存进一个[浮点数](https://www.zhihu.com/search?q=浮点数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})的，当浮点数运算的前后结果都在第〇层以内时，这样的小数也是可以做到精确计算的。



所以，这个问题其实描述不准确，准确的说法应该是满足第〇层规律的小数可以直接使用CPU硬件指令直接进行精确计算，满足1，2，3，层规律的小数无法直接使用CPU指令精确计算，只能使用特殊的软件算法实现精确计算，但由于效率不高，它们仅仅用于数学工具类应用，常规应用并不使用类似的方法。

### IEEE-754标准

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/IEEE浮点数格式.jpg)

`(-1)^s*M*2^E`

* Sign 阶符
* mantissa 尾数
* exponent 阶码

M的取值范围是：1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。**IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。**比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字

E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，**所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。**

比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/IEEE-尾数隐藏第一位.jpg)



#### 规格化浮点数表示

```bash
1011.1101
= 0.10111101 * 2^4
= 10.111101 * 2^2
= 1.0111101 * 2^3 (格式化)
= (-1)^0 * 1.0111101 * 2^3
s=0, M=1.0111101, E=3 
```

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/浮点数表示规格.jpg)

#### 真值转浮点数

思路：

1. 将小数点前整数转成二进制
2. 将小数点后小数转成二进制，使用乘2取整法
3. 规范浮点数表示式
4. 计算s、m和e的值

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/真值转浮点数.jpg)

#### 浮点数转真值

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/浮点数转真值.jpg)





#### 除2取余



#### 乘2取整

乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分 
为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数，下面举例： 
例1：将0.125换算为二进制 
得出结果：将0.125换算为二进制（0.001）2 
分析：

第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25; 
第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5; 
第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0; 
第四步,读数,从第一位读起,读到最后一位,即为0.001。

**学习二进制，最好的方法就是类比。**

考虑一个十进制小数0.123，我们可以用“乘10取整”法得到它的每一位小数：第一位小数是0.123\*10=1.23，取整数1；第二位小数：0.23*10=2.3，取整数2……

#### float精度和有效位

精度主要取决于尾数部分的位数。

对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19*10^-7，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。

同理 float64（单精度）的尾数部分为 52位，最小为2^-52，约为2.22*10^-16，所以精确到小数点后15位，加上小数点前的一位，有效位数为16位。

**float32**，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/float32.webp)



**float64**，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/float64.webp)

#### 科学计数法

浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：

- 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
- 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
- float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。

所以，`1.4e-43`就是`1.4e-45 * 10 * 10`,  因为`i`初始化值为10

### 定点数



### 引用

1. https://blog.csdn.net/mynote/article/details/9157779
2. https://www.zhihu.com/question/497425753/answer/2219892804
3. https://www.zhihu.com/question/497425753/answer/2216870296
4. https://www.zhihu.com/question/497425753/answer/2232016866
5. https://blog.csdn.net/weixin_42552410/article/details/113020126
6. https://blog.51cto.com/yuqix/386018
7. https://www.bilibili.com/video/BV1f54y167sg/?spm_id_from=333.788.recommend_more_video.0&vd_source=2795986600b37194ea1056cddb9856fa
8. https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html



