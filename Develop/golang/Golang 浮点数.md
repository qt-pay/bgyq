## Golang 浮点数

### 计算机为什么不能精确

**因为实数不可数，以及可计算数是否相等不可判定**

常见的计算机内的数值表达方式实际上有很多种，如整数、定点数、浮点数大部分人都很熟悉，但实际上不仅仅有二进制，还有十进制数，比如Python的decimal库，可以试试看：

```python
>>> from decimal import Decimal
>>> 1.2 - 1.0
0.19999999999999996
>>> Decimal('1.2') - Decimal('1.0')
Decimal('0.2')
```

许多可以轻松地用十进制表示的数字不能用二进制浮点表示。例如，在输入以下语句后:

```python
>>> x = 1.2
```

为 `x` 存储的值是与十进制的值 `1.2` (非常接近) 的近似值，但不完全等于它。 在典型的机器上，实际存储的值是：

```python
1.0011001100110011001100110011001100110011001100110011 (binary)
```

它对应于十进制数值:

```python
1.1999999999999999555910790149937383830547332763671875 (decimal)
```

典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。



本质上是因为计算机不能精确计算无限的数。

但是这种无限，其实有多个层面。

第0层：十进制是个[有限小数](https://www.zhihu.com/search?q=有限小数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})，二进制也是个有限小数，比如 0.5, 0.25, 0.125, 0.375 等等小数。

第一层：十进制是一个有限小数，二进制是个[无限小数](https://www.zhihu.com/search?q=无限小数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})。比如 0.2 这样的数。

第二层，十进制二进制都是无限小数，但可以表达为分数，并且分子分母都是有限的二进制数。

第三层，十进制二进制都是无限小数，不可以表达为分数，但可以通过特定的数学符号运算稳定获得。

第四层，无论在何种形态都是无限小数，无法表达为有限分数，也无法用有限的数学符号运算获得。

------

第四层的小数是几乎所有计算机程序都无法精确计算的。

第三层的小数，在一部分支持符号计算的数学工具内可以进行精确计算（直接以符号形态进行多项式计算）。在大部分普通应用中无法精确计算。

第二层的小数，在支持分数运算的数学工具内可以精确计算，在大部分普通应用内无法精确计算。

第一层的小数，使用一部分基于十进制运算的库可以精确计算，在大部分二进制计算的应用内无法精确计算。——原因也很明确，计算机无法精确计算无限，而这些数在二进制下是无限小数。

至于第〇层的小数，其实所有应用程序都能够精确计算，精确储存。——所有的整数其实都满足第零层规律，因此这些整数是能够精确的保存进一个[浮点数](https://www.zhihu.com/search?q=浮点数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2232016866})的，当浮点数运算的前后结果都在第〇层以内时，这样的小数也是可以做到精确计算的。



所以，这个问题其实描述不准确，准确的说法应该是满足第〇层规律的小数可以直接使用CPU硬件指令直接进行精确计算，满足1，2，3，层规律的小数无法直接使用CPU指令精确计算，只能使用特殊的软件算法实现精确计算，但由于效率不高，它们仅仅用于数学工具类应用，常规应用并不使用类似的方法。

### IEEE-754标准

#### 除2取余



#### 乘2取整

乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分 
为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数，下面举例： 
例1：将0.125换算为二进制 
得出结果：将0.125换算为二进制（0.001）2 
分析：

第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25; 
第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5; 
第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0; 
第四步,读数,从第一位读起,读到最后一位,即为0.001。

**学习二进制，最好的方法就是类比。**

考虑一个十进制小数0.123，我们可以用“乘10取整”法得到它的每一位小数：第一位小数是0.123\*10=1.23，取整数1；第二位小数：0.23*10=2.3，取整数2……

#### float精度和有效位

精度主要取决于尾数部分的位数。

对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19*10^-7，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。

同理 float64（单精度）的尾数部分为 52位，最小为2^-52，约为2.22*10^-16，所以精确到小数点后15位，加上小数点前的一位，有效位数为16位。

**float32**，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/float32.webp)



**float64**，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数

![](https://image-1300760561.cos.ap-beijing.myqcloud.com/bgyq-blog/float64.webp)

#### 科学计数法

浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：

- 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
- 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
- float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。


所以，`1.4e-43`就是`1.4e-45 * 10 * 10`,  因为`i`初始化值为10

### 引用

1. https://blog.csdn.net/mynote/article/details/9157779
2. https://www.zhihu.com/question/497425753/answer/2219892804
3. https://www.zhihu.com/question/497425753/answer/2216870296
4. https://www.zhihu.com/question/497425753/answer/2232016866