### Mysql Change buffer and buffer pool - H3C

https://juejin.cn/post/6844903874172551181



#### OS Cached/Buffers

**缓存（cached）**是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除。

**缓冲（buffers）**是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。



应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在**缓存**(cache)里，避免每次都去访问数据库。

操作系统，会有**缓冲池**(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。

速度快，那**为啥不把所有数据都放到缓冲池里**？

凡事都具备两面性，抛开数据易失性不说，访问快速的反面是存储容量小：

（1）缓存访问快，但容量小，数据库存储了200G数据，缓存容量可能只有64G；

（2）内存访问快，但容量小，买一台笔记本磁盘有2T，内存可能只有16G；

因此，只能把“最热”的数据放到“最近”的地方，以“最大限度”的降低磁盘访问



##### 预读

磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。

数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。



#### 基础： 内存

数据在内存中，才能被Mysql client and Mysql serve 访问和操作。即，需要将page 加载到 memory。

change buffer merge， 是将从磁盘上新加载的page与memory中已经修改的数据，进行合并，并展示最终的数据给应用者。

内存命中率，是指数据是否能直接在内存中读取到，如果不命中就需要从磁盘加载数据到内存中。数据终归是要在内存中被操作使用的。

#### Mysql buffer pool

写的真好：https://juejin.cn/post/6844903874172551181

对于读请求，缓冲池能够减少磁盘IO。

MySQL作为一个存储系统，同样具有**缓冲池**(buffer pool)机制，以避免每次查询数据都进行磁盘IO。

缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用

InnoDB引擎的缓冲池。

##### 预读失效

由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。

要优化预读失效，思路是：

（1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；

（2）让真正被读取的页，才挪到缓冲池LRU的头部；

以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。

具体方法是：

（1）将LRU分为两个部分：

- 新生代(new sublist)
- 老生代(old sublist)

（2）新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；

（3）新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：

- 如果数据真正被读取（预读成功），才会加入到新生代的头部
- 如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池


举个例子，整个缓冲池LRU如上图：

（1）整个LRU长度是10；

（2）前70%是新生代；

（3）后30%是老生代；

（4）新老生代首尾相连；



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6be06a8fc1~tplv-t2oaga2asx-watermark.awebp)



假如有一个页号为50的新页被预读加入缓冲池：

（1）50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；

（2）假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6bf49c19c4~tplv-t2oaga2asx-watermark.awebp)



假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：

（1）它会被立刻加入到新生代的头部；

（2）新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；

改进版缓冲池LRU能够很好的解决“预读失败”的问题。


作者：58沈剑_架构师之路
链接：https://juejin.cn/post/6844903874172551181
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 缓存池污染

当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。

例如，有一个数据量较大的用户表，当执行：

select * from user where name like "%shenjian%";

虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：

（1）把页加到缓冲池（插入老生代头部）；

（2）从页里读出相关的row（插入新生代头部）；

（3）row里的name字段和字符串shenjian进行比较，如果符合条件，加入到结果集中；

（4）…直到扫描完所有页中的所有row…

如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出

如何解决缓存池污染

MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：

（1）假设T=老生代停留时间窗口；

（2）插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；

（3）只有**满足**“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6bf4aa4dbc~tplv-t2oaga2asx-watermark.awebp)



继续举例，假如批量数据扫描，有51，52，53，54，55等五个页面将要依次被访问。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6bf7ea6308~tplv-t2oaga2asx-watermark.awebp)



如果没有“老生代停留时间窗口”的策略，这些批量被访问的页面，会换出大量热数据。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6bf92f95ed~tplv-t2oaga2asx-watermark.awebp)



加入“老生代停留时间窗口”策略后，短时间内被大量加载的页，并不会立刻插入新生代头部，而是优先淘汰那些，短期内仅仅访问了一次的页。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/25/16b8cf6bfe072707~tplv-t2oaga2asx-watermark.awebp)



而只有在老生代呆的时间足够久（一直被访问-），停留时间大于T，才会被插入新生代头部。


作者：58沈剑_架构师之路
链接：https://juejin.cn/post/6844903874172551181
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 参数配置

**参数**：innodb_buffer_pool_size

**介绍**：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。

**参数**：innodb_old_blocks_pct

**介绍**：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。

如果把这个参数设为100，就退化为普通LRU了。

**参数**：innodb_old_blocks_time

**介绍**：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。




##### 总结

（1）MySQL数据存储包含 `内存` 与`磁盘`**两个部分**；

（2）内存缓冲池(buffer pool)`以页为单位`，缓存最热的数据页(data page)与索引页(index page)；

（3）InnoDB以变种LRU算法管理缓冲池，并能够`解决`“**预读失效**”与“**缓冲池污染**”的`问题`；

（4）缓冲池(buffer pool)是一种**常见的降低磁盘访问的机制；**

（5）缓冲池通常**以页(page)为单位缓存数据；**

（6）缓冲池的**常见管理算法是LRU**，memcache，OS，InnoDB都使用了这种算法；

（7）InnoDB对普通LRU进行了优化：

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题




#### Mysql change buffer

写请求，IO优化。

在MySQL5.5之前，叫`插入缓冲`(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做`写缓冲`(change buffer)。

它是一种应用在**非唯一普通索引页**(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的**目的**是`降低写操作的磁盘IO，提升数据库性能。`

##### 限制

Change Buffer 并不是适用于所有场景，以下两种情况不适合开启 Change Buffer ：

- **1、数据库都是唯一索引**

如果数据库都是唯一索引，那么在每次操作的时候都需要判断索引是否有冲突，势必要将数据加载到缓存中对比，因此也用不到 Change Buffer。

- **2、写入一个数据后，会立刻读取它**

写入一个数据后，会立刻读取它，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

**以下几种情况开启 Change Buffer，会使得 MySQL 数据库明显提升**：

- **1、数据库大部分是非唯一索引**
- **2、业务是写多读少**
- **3、写入数据之后并不会立即读取它**

总体来说 InnoDB 的写缓存（Change Buffer）应用得当，会极大提高 MySQL 数据库的性能，使用不恰当的话，可能会适得其反



##### 基础

理解change buffer，首先要明确概念： 

（1）mysql数据存储在主键索引树的叶子节点。 

（2）普通索引和唯一索引也都有自己的索引树，树的叶子节点存储的是主键ID。

（3）做更新操作（插入，更新，删除）会同时更新所有的索引树结构。

insert：主键索引树和唯一建索引树的肯定都要更新，肯定是无法用到change buffer的；但是普通索引树的更新，是可以使用change buffer的。

 update：只要涉及到相关字段更新，就要同时更新相应的索引树。道理同上。 

【显然，insert操作的影响更大，如果有多个唯一索引，insert对内存命中率会有极大影响】 

1、减少读磁盘：仅仅是减少的是对二级普通索引页的读磁盘操作，而对于其他类型的页(唯一索引，主键索引)还是要读磁盘的。 

2、减少内存占用：change buffer虽然还是需要内存占用(记录数据更新动作)，但相比于数据页来说(默认16K)，所占的内存还是小了很多的。

##### merge/purge

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。

> merge 和 操作系统将脏页落盘毫无干系--

merge 的执行流程是这样的：

* 从磁盘读入数据页到内存（老版本的数据页）；
* 从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；
* 写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。

到这里 merge 过程就结束了。这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。

更新先是在内存中的数据页更新； 完了 Commit 的时候，将更新写入 Redo Log； Redo Log 的写走的是两阶段写协议，保证 Redo Log 和 Binlog 对更新达成共识； Redo Log 的 Commit 阶段执行成功，再响应客户端； 但是！！！脏页刷盘的时候，是将内存中数据页的最新值，写入磁盘中的数据文件（表文件），而不是 Redo Log 中；正是由于 Redo Log 的存在，可以让内存中出现大量的脏页。

哪些情况出触发merge：

（0）访问change buffers中的数据页

（1）有一个后台线程，会认为数据库空闲时（定期merge）；

（2）数据库缓冲池不够用时；

（3）数据库正常关闭时；

（4）redo log写满时；

##### change buffer and redo

redo：记录数据页的操作记录

change buffer：在内存中完成数据的修改（merge），减少落盘操作。

脏页：内存中数据页修改和磁盘上不一致即脏页。



change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？

答案是，不会。

change buffer的merge操作，先把change buffer的操作更新到内存的数据页中，此操作写到redo log中，mysql未宕机，redo log写满后需要移动check point点时，通过判断内存中数据和磁盘是否一致即是否是脏页来刷新到磁盘中，当mysql宕机后没有内存即没有脏页,通过redo log来恢复。



redo log是物理日志，记录的是数据页的修改，如果数据页不在内存中，都没有去修改数据页，这时使用了change buffer，redo log中就记录SQL语句在change buffe中做操作的过程。脏页落盘，则是数据真正持久化到磁盘存储了



更新先是在内存中的数据页更新； 完了 Commit 的时候，将更新写入 Redo Log； Redo Log 的写走的是两阶段写协议，保证 Redo Log 和 Binlog 对更新达成共识； Redo Log 的 Commit 阶段执行成功，再响应客户端； 但是！！！脏页刷盘的时候，是将内存中数据页的最新值，写入磁盘中的数据文件（表文件），而不是 Redo Log 中；正是由于 Redo Log 的存在，可以让内存中出现大量的脏页。

##### 参数

参数：innodb_change_buffer_max_size

介绍：配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%。

PS： 写多读少的业务，才需要调大这个值，读多写少的业务，25%其实也多了。

参数：innodb_change_buffering

**介绍**：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes等。




#### 微服务分库感悟

从change buffer 的栗子，可以很容易联想到，微服务架构的好处：

每个应用使用独立的数据库，可以根据不同的业务模块场景，来优化对应的数据库引擎。

比如：

* 写多读少就开启changer buffer
* 写入后立刻读就关闭changer buffer（注册后立刻登陆）。

如果，这两个表是集中在一个数据库中，那你该如何配置数据库呢？？？